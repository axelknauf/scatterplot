<!DOCTYPE html>
<html>
  <head>
    <title>Scatter Plot</title>
    <meta charset="utf-8" />
  </head>
  <body>
    <div id="smap"></div>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script type="text/javascript">
      // Data to draw -----------------------------------
      // Name, proponent, active
      const csv = [
        [ "John Doe","5","5" ],
        [ "Marylin Monroe","7","4" ]
      ];
      const data = csv.map(entry => ({
        name: entry[0],
        x: entry[1],
        y: entry[2]
      }));
    //   const data = [{ name: "Foo", x: 4, y: 9 }, { name: "Bar", x: 5, y: 7 }];

      // Config and settings -----------------------------------
      const width = 800,
        height = 600;
      const xAxisConfig = {
        min: 0, 
        max: 10,
        label: "Passive (0) - Active (10)"
      };
      const yAxisConfig = {
        min: 0, 
        max: 10,
        label: "Opponent (0) - Proponent (10)"
      };
      const margin = { top: 20, right: 30, bottom: 30, left: 40 };

      const circleRadius = 4;
      const circleLineWidth = 1.5;
      const circleStrokeColor = "steelblue";
      const circleFillColor = circleStrokeColor; //"none";

      const labelFontSize = 14;
      const labelFontFamily = "sans-serif";

      // D3 drawing logic -----------------------------------
      const x = d3
        .scaleLinear()
        .domain([xAxisConfig.min, xAxisConfig.max])
        .range([margin.left, width - margin.right]);

      const y = d3
        .scaleLinear()
        .domain([yAxisConfig.min, yAxisConfig.max])
        .range([height - margin.bottom, margin.top]);

      const xAxis = g =>
        g
          .attr("transform", `translate(0,${height - margin.bottom})`)
          .call(d3.axisBottom(x))
          .call(g =>
            g
              .append("text")
              .attr("x", width - margin.right)
              .attr("y", -4)
              .attr("fill", "#000")
              .attr("font-weight", "bold")
              .attr("text-anchor", "end")
              .text(data.x)
          );

      const yAxis = g =>
        g
          .attr("transform", `translate(${margin.left},0)`)
          .call(d3.axisLeft(y))
          .call(g =>
            g
              .select(".tick:last-of-type text")
              .clone()
              .attr("x", 4)
              .attr("text-anchor", "start")
              .attr("font-weight", "bold")
              .text(data.y)
          );

      function dodge(text, iterations = 300) {
        const nodes = text.nodes();
        const left = text =>
          text.attr("text-anchor", "start").attr("dy", "0.32em");
        const right = text =>
          text.attr("text-anchor", "end").attr("dy", "0.32em");
        const top = text =>
          text.attr("text-anchor", "middle").attr("dy", "0.0em");
        const bottom = text =>
          text.attr("text-anchor", "middle").attr("dy", "0.8em");
        const points = nodes.map(node => ({
          fx: +node.getAttribute("x"),
          fy: +node.getAttribute("y")
        }));
        const labels = points.map(({ fx, fy }) => ({ x: fx, y: fy }));
        const links = points.map((source, i) => ({
          source,
          target: labels[i]
        }));

        const simulation = d3
          .forceSimulation(points.concat(labels))
          .force("charge", d3.forceManyBody().distanceMax(80))
          .force(
            "link",
            d3
              .forceLink(links)
              .distance(4)
              .iterations(4)
          )
          .stop();

        for (let i = 0; i < iterations; ++i) simulation.tick();

        text
          .attr("x", (_, i) => labels[i].x)
          .attr("y", (_, i) => labels[i].y)
          .each(function(_, i) {
            const a = Math.atan2(
              labels[i].y - points[i].fy,
              labels[i].x - points[i].fx
            );
            d3.select(this).call(
              a > Math.PI / 4 && a <= (Math.PI * 3) / 4
                ? bottom
                : a > -Math.PI / 4 && a <= Math.PI / 4
                ? left
                : a > (-Math.PI * 3) / 4 && a <= (Math.PI * 3) / 4
                ? top
                : right
            );
          });
      }

      function chart() {
        const svg = d3
          .select("#smap")
          .append("svg")
          .attr("width", width)
          .attr("height", height);

        svg.append("g").call(xAxis);

        svg.append("g").call(yAxis);

        svg
          .append("g")
          .attr("stroke", circleStrokeColor)
          .attr("stroke-width", circleLineWidth)
          .attr("fill", circleFillColor)
          .selectAll("circle")
          .data(data)
          .enter()
          .append("circle")
          .attr("cx", d => x(d.x))
          .attr("cy", d => y(d.y))
          .attr("r", circleRadius);

        svg
          .append("g")
          .attr("font-family", labelFontFamily)
          .attr("font-size", labelFontSize)
          .selectAll("text")
          .data(data)
          .enter()
          .append("text")
          .attr("x", d => x(d.x))
          .attr("y", d => y(d.y))
          .text(d => d.name)
          .call(dodge);

        return svg.node();
      }

      chart();
    </script>
  </body>
</html>
